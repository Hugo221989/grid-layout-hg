{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../projects/angular-grid-layout/src/lib/utils/react-grid-layout.utils.ts","../projects/angular-grid-layout/src/lib/utils/passive-listeners.ts","../projects/angular-grid-layout/src/lib/utils/pointer.utils.ts","../projects/angular-grid-layout/src/lib/utils/grid.utils.ts","../projects/angular-grid-layout/src/lib/directives/drag-handle.ts","../projects/angular-grid-layout/src/lib/directives/resize-handle.ts","../../projects/angular-grid-layout/src/lib/grid.definitions.ts","../projects/angular-grid-layout/src/lib/coercion/boolean-property.ts","../projects/angular-grid-layout/src/lib/coercion/number-property.ts","../../projects/angular-grid-layout/src/lib/grid.service.ts","../projects/angular-grid-layout/src/lib/grid-item/grid-item.component.ts","../projects/angular-grid-layout/src/lib/utils/operators.ts","../projects/angular-grid-layout/src/lib/utils/client-rect.ts","../projects/angular-grid-layout/src/lib/grid-item/grid-item.component.html","../projects/angular-grid-layout/src/lib/utils/scroll.ts","../../projects/angular-grid-layout/src/lib/grid.component.ts","../../projects/angular-grid-layout/src/lib/grid.component.html","../../projects/angular-grid-layout/src/lib/grid.module.ts"],"names":["Object","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","__spread","arguments","concat","bottom","layout","bottomY","max","len","y","h","cloneLayoutItem","layoutItem","clonedLayoutItem","w","x","id","moved","static","undefined","minW","maxW","minH","maxH","isDraggable","isResizable","collides","l1","l2","compact","compactType","cols","compareWith","getStatics","sorted","sortLayoutItems","out","Array","l","compactItem","indexOf","heightWidth","resolveCompactionCollision","item","moveToCoord","axis","sizeProp","map","otherItem","fullLayout","compactH","Math","min","getFirstCollision","filter","moveElement","isUserAction","preventCollision","log","String","oldX","oldY","reverse","collisions","getAllCollisions","collision","moveElementAwayFromCollision","collidesWith","itemToMove","compactV","fakeItem","sort","a","b","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","args","_i","supportsPassiveEvents","ktdNormalizePassiveListenerOptions","options","window","addEventListener","defineProperty","get","ktdSupportsPassiveEventListeners","capture","passiveEventListenerOptions","passive","activeEventListenerOptions","isMobile","ktdIsMobileOrTablet","isMobileDevice","test","navigator","userAgent","isIOSMobileDevice","platform","maxTouchPoints","ktdIsMouseEvent","event","clientX","ktdPointerClientX","touches","ktdPointerClientY","clientY","ktdPointerClient","ktdMouseOrTouchDown","element","touchNumber","iif","fromEvent","pipe","touchEvent","mouseEvent","button","ktdMouseOrTouchEnd","merge","ktdTouchEnd","screenXPosToGridValue","screenXPos","width","round","screenYPosToGridValue","screenYPos","rowHeight","height","ktdGridItemDragging","gridItemId","config","compactionType","draggingData","pointerDownEvent","pointerDragEvent","gridElemClientRect","dragElemClientRect","scrollDifference","draggingElemPrevItem","find","clientStartX","clientStartY","offsetX","left","offsetY","top","gridRelXPos","gridRelYPos","assign","layoutItems","draggedLayoutItem","newLayoutItems","draggedItemPos","ktdGridItemResizing","resizeElemOffsetX","resizeElemOffsetY","colliding","hasCollision","shrunkDimension","getDimensionToShrink","lastShrunk","KTD_GRID_DRAG_HANDLE","InjectionToken","this","KtdGridDragHandle","i0","ɵɵdirectiveInject","ElementRef","selectors","hostAttrs","features","ɵɵProvidersFeature","provide","useExisting","KTD_GRID_RESIZE_HANDLE","KtdGridResizeHandle","GRID_ITEM_GET_RENDER_DATA_TOKEN","coerceBooleanProperty","coerceNumberProperty","fallbackValue","isNaN","parseFloat","Number","_isNumberValue","activeCapturingEventOptions","KtdGridService","ngZone","touchMoveSubject","Subject","touchMove$","asObservable","registerTouchMoveSubscription","prototype","ngOnDestroy","touchMoveSubscription","unsubscribe","mouseOrTouchMove$","_this","runOutsideAngular","document","subscribe","ɵɵinject","NgZone","factory","ɵfac","providedIn","KtdGridItemComponent","elementRef","gridService","renderer","getItemRenderData","transition","_dragStartThreshold","_draggable","_draggable$","BehaviorSubject","_resizable","_resizable$","dragStartSubject","resizeStartSubject","subscriptions","dragStart$","resizeStart$","_id","val","ngOnInit","gridItemRenderData","setStyles","ngAfterContentInit","_dragStart$","_resizeStart$","forEach","sub","_a","setStyle","nativeElement","switchMap","draggable","_dragHandles","changes","startWith","dragHandles","apply","toArray","dragHandle","exhaustMap","startEvent","target","type","preventDefault","zone","startPointer","takeUntil","source","Observable","observer","moveEvent","movePointer","abs","dragStartThreshold","take","NEVER","resizable","_resizeHandles","resizeHandles","resizeElem","resizeHandle","getMutableClientRect","clientRect","getBoundingClientRect","right","Renderer2","contentQueries","rf","ctx","dirIndex","i0.ɵɵprojection","i0.ɵɵelement","incrementVerticalScroll","node","amount","scrollBy","scrollTop","incrementHorizontalScroll","scrollLeft","scrollToDirectionInterval$","scrollNode","verticalScrollDirection","horizontalScrollDirection","scrollStep","interval","animationFrameScheduler","tap","source$","ktdScrollIfNearElementClientRect$","scrollableParent","scrollableParentClientRect","scrollableParentScrollWidth","defaultView","getViewportSize","body","scrollWidth","documentElement","disableHorizontal","pointerX","pointerY","yThreshold","getVerticalScrollDirection","xThreshold","getHorizontalScrollDirection","disableVertical","distinctUntilChanged","prev","actual","ktdGetScrollTotalRelativeDifference$","scrollInitialPosition","getViewportScrollPosition","newTop","newLeft","viewportScrollPosition","_window","innerWidth","innerHeight","windowRef","documentRect","scrollY","scrollX","getDragResizeEventData","gridItem","gridItemRef","layoutToRenderItems","renderItems","layout_1","layout_1_1","getGridHeight","reduce","acc","cur","parseRenderItemToPixels","renderItem","__gridItemGetRenderDataFactoryFunc","gridCmp","ktdGridItemGetRenderDataFactoryFunc","KtdGridComponent","layoutUpdated","EventEmitter","dragStarted","resizeStarted","dragEnded","resizeEnded","_compactOnPropsChange","_preventCollision","_scrollSpeed","_compactType","_rowHeight","_cols","_layout","ngOnChanges","needsCompactLayout","needsRecalculateRenderData","compactOnPropsChange","compactLayout","calculateRenderData","initSubscriptions","ngAfterContentChecked","render","resize","getItemsRenderData","_gridItemsRenderData","itemId","_height","updateGridItemsStyles","_gridItems","console","gridItems","run","emit","calcNewStateFunc","performDragSequence$","getElementById","addClass","newLayout","placeholderElement","createElement","style","transform","appendChild","scrollSubscription","scrollSpeed","subscription","combineLatest","of","_b","currentLayout","_c","placeholderStyles","removeClass","removeChild","complete","useFactory","deps","ɵɵNgOnChangesFeature","ngContentSelectors","decls","vars","template","KtdGridModule","providers","imports","CommonModule","declarations","exports","index"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","\n/**\n * IMPORTANT:\n * This utils are taken from the project: https://github.com/STRML/react-grid-layout.\n * The code should be as less modified as possible for easy maintenance.\n */\n\n// Disable lint since we don't want to modify this code\n// tslint:disable\nexport type LayoutItem = {\n    w: number;\n    h: number;\n    x: number;\n    y: number;\n    id: string;\n    minW?: number;\n    minH?: number;\n    maxW?: number;\n    maxH?: number;\n    moved?: boolean;\n    static?: boolean;\n    isDraggable?: boolean | null | undefined;\n    isResizable?: boolean | null | undefined;\n};\nexport type Layout = Array<LayoutItem>;\nexport type Position = {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n};\nexport type ReactDraggableCallbackData = {\n    node: HTMLElement;\n    x?: number;\n    y?: number;\n    deltaX: number;\n    deltaY: number;\n    lastX?: number;\n    lastY?: number;\n};\n\nexport type PartialPosition = { left: number; top: number };\nexport type DroppingPosition = { x: number; y: number; e: Event };\nexport type Size = { width: number; height: number };\nexport type GridDragEvent = {\n    e: Event;\n    node: HTMLElement;\n    newPosition: PartialPosition;\n};\nexport type GridResizeEvent = { e: Event; node: HTMLElement; size: Size };\nexport type DragOverEvent = MouseEvent & {\n    nativeEvent: {\n        layerX: number;\n        layerY: number;\n        target: {\n            className: String;\n        };\n    };\n};\n\n//type REl = ReactElement<any>;\n//export type ReactChildren = ReactChildrenArray<REl>;\n\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\nexport type EventCallback = (\n    arg0: Layout,\n    oldItem: LayoutItem | null | undefined,\n    newItem: LayoutItem | null | undefined,\n    placeholder: LayoutItem | null | undefined,\n    arg4: Event,\n    arg5: HTMLElement | null | undefined,\n) => void;\nexport type CompactType = ('horizontal' | 'vertical') | null | undefined;\n\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport function bottom(layout: Layout): number {\n    let max = 0,\n        bottomY;\n    for (let i = 0, len = layout.length; i < len; i++) {\n        bottomY = layout[i].y + layout[i].h;\n        if (bottomY > max) {\n            max = bottomY;\n        }\n    }\n    return max;\n}\n\nexport function cloneLayout(layout: Layout): Layout {\n    const newLayout = Array(layout.length);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        newLayout[i] = cloneLayoutItem(layout[i]);\n    }\n    return newLayout;\n}\n\n// Fast path to cloning, since this is monomorphic\n/** NOTE: This code has been modified from the original source */\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\n    const clonedLayoutItem: LayoutItem = {\n        w: layoutItem.w,\n        h: layoutItem.h,\n        x: layoutItem.x,\n        y: layoutItem.y,\n        id: layoutItem.id,\n        moved: !!layoutItem.moved,\n        static: !!layoutItem.static,\n    };\n\n    if (layoutItem.minW !== undefined) { clonedLayoutItem.minW = layoutItem.minW;}\n    if (layoutItem.maxW !== undefined) { clonedLayoutItem.maxW = layoutItem.maxW;}\n    if (layoutItem.minH !== undefined) { clonedLayoutItem.minH = layoutItem.minH;}\n    if (layoutItem.maxH !== undefined) { clonedLayoutItem.maxH = layoutItem.maxH;}\n    // These can be null\n    if (layoutItem.isDraggable !== undefined) { clonedLayoutItem.isDraggable = layoutItem.isDraggable;}\n    if (layoutItem.isResizable !== undefined) { clonedLayoutItem.isResizable = layoutItem.isResizable;}\n\n    return clonedLayoutItem;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\n    if (l1.id === l2.id) {\n        return false;\n    } // same element\n    if (l1.x + l1.w <= l2.x) {\n        return false;\n    } // l1 is left of l2\n    if (l1.x >= l2.x + l2.w) {\n        return false;\n    } // l1 is right of l2\n    if (l1.y + l1.h <= l2.y) {\n        return false;\n    } // l1 is above l2\n    if (l1.y >= l2.y + l2.h) {\n        return false;\n    } // l1 is below l2\n    return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\nexport function compact(\n    layout: Layout,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // Statics go in the compareWith array right away so items flow around them.\n    const compareWith = getStatics(layout);\n    // We go through the items by row and column.\n    const sorted = sortLayoutItems(layout, compactType);\n    // Holding for new items.\n    const out = Array(layout.length);\n\n    for (let i = 0, len = sorted.length; i < len; i++) {\n        let l = cloneLayoutItem(sorted[i]);\n\n        // Don't move static elements\n        if (!l.static) {\n            l = compactItem(compareWith, l, compactType, cols, sorted);\n\n            // Add to comparison array. We only collide with items before this one.\n            // Statics are already in this array.\n            compareWith.push(l);\n        }\n\n        // Add to output array to make sure they still come out in the right order.\n        out[layout.indexOf(sorted[i])] = l;\n\n        // Clear moved flag, if it exists.\n        l.moved = false;\n    }\n\n    return out;\n}\n\nconst heightWidth = {x: 'w', y: 'h'};\n\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(\n    layout: Layout,\n    item: LayoutItem,\n    moveToCoord: number,\n    axis: 'x' | 'y',\n) {\n    const sizeProp = heightWidth[axis];\n    item[axis] += 1;\n    const itemIndex = layout\n        .map(layoutItem => {\n            return layoutItem.id;\n        })\n        .indexOf(item.id);\n\n    // Go through each item we collide with.\n    for (let i = itemIndex + 1; i < layout.length; i++) {\n        const otherItem = layout[i];\n        // Ignore static items\n        if (otherItem.static) {\n            continue;\n        }\n\n        // Optimization: we can break early if we know we're past this el\n        // We can do this b/c it's a sorted layout\n        if (otherItem.y > item.y + item.h) {\n            break;\n        }\n\n        if (collides(item, otherItem)) {\n            resolveCompactionCollision(\n                layout,\n                otherItem,\n                moveToCoord + item[sizeProp],\n                axis,\n            );\n        }\n    }\n\n    item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n */\nexport function compactItem(\n    compareWith: Layout,\n    l: LayoutItem,\n    compactType: CompactType,\n    cols: number,\n    fullLayout: Layout,\n): LayoutItem {\n    const compactV = compactType === 'vertical';\n    const compactH = compactType === 'horizontal';\n    if (compactV) {\n        // Bottom 'y' possible is the bottom of the layout.\n        // This allows you to do nice stuff like specify {y: Infinity}\n        // This is here because the layout must be sorted in order to get the correct bottom `y`.\n        l.y = Math.min(bottom(compareWith), l.y);\n        // Move the element up as far as it can go without colliding.\n        while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n            l.y--;\n        }\n    } else if (compactH) {\n        l.y = Math.min(bottom(compareWith), l.y);\n        // Move the element left as far as it can go without colliding.\n        while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n            l.x--;\n        }\n    }\n\n    // Move it down, and keep moving it down if it's colliding.\n    let collides;\n    while ((collides = getFirstCollision(compareWith, l))) {\n        if (compactH) {\n            resolveCompactionCollision(\n                fullLayout,\n                l,\n                collides.x + collides.w,\n                'x',\n            );\n        } else {\n            resolveCompactionCollision(\n                fullLayout,\n                l,\n                collides.y + collides.h,\n                'y',\n            );\n        }\n        // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n        if (compactH && l.x + l.w > cols) {\n            l.x = cols - l.w;\n            l.y++;\n        }\n    }\n    return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nexport function correctBounds(layout: Layout, bounds: { cols: number }): Layout {\n    const collidesWith = getStatics(layout);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const l = layout[i];\n        // Overflows right\n        if (l.x + l.w > bounds.cols) {\n            l.x = bounds.cols - l.w;\n        }\n        // Overflows left\n        if (l.x < 0) {\n            l.x = 0;\n            l.w = bounds.cols;\n        }\n        if (!l.static) {\n            collidesWith.push(l);\n        } else {\n            // If this is static and collides with other statics, we must move it down.\n            // We have to do something nicer than just letting them overlap.\n            while (getFirstCollision(collidesWith, l)) {\n                l.y++;\n            }\n        }\n    }\n    return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nexport function getLayoutItem(\n    layout: Layout,\n    id: string,\n): LayoutItem | null | undefined {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (layout[i].id === id) {\n            return layout[i];\n        }\n    }\n    return null;\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nexport function getFirstCollision(\n    layout: Layout,\n    layoutItem: LayoutItem,\n): LayoutItem | null | undefined {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (collides(layout[i], layoutItem)) {\n            return layout[i];\n        }\n    }\n    return null;\n}\n\nexport function getAllCollisions(\n    layout: Layout,\n    layoutItem: LayoutItem,\n): Array<LayoutItem> {\n    return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nexport function getStatics(layout: Layout): Array<LayoutItem> {\n    return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nexport function moveElement(\n    layout: Layout,\n    l: LayoutItem,\n    x: number | null | undefined,\n    y: number | null | undefined,\n    isUserAction: boolean | null | undefined,\n    preventCollision: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // If this is static and not explicitly enabled as draggable,\n    // no move is possible, so we can short-circuit this immediately.\n    if (l.static && l.isDraggable !== true) {\n        return layout;\n    }\n\n    // Short-circuit if nothing to do.\n    if (l.y === y && l.x === x) {\n        return layout;\n    }\n\n    log(\n        `Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${\n            l.y\n        }]`,\n    );\n    const oldX = l.x;\n    const oldY = l.y;\n\n    // This is quite a bit faster than extending the object\n    if (typeof x === 'number') {\n        l.x = x;\n    }\n    if (typeof y === 'number') {\n        l.y = y;\n    }\n    l.moved = true;\n\n    // If this collides with anything, move it.\n    // When doing this comparison, we have to sort the items we compare with\n    // to ensure, in the case of multiple collisions, that we're getting the\n    // nearest collision.\n    let sorted = sortLayoutItems(layout, compactType);\n    const movingUp =\n        compactType === 'vertical' && typeof y === 'number'\n            ? oldY >= y\n            : compactType === 'horizontal' && typeof x === 'number'\n            ? oldX >= x\n            : false;\n    if (movingUp) {\n        sorted = sorted.reverse();\n    }\n    const collisions = getAllCollisions(sorted, l);\n\n    // There was a collision; abort\n    if (preventCollision && collisions.length) {\n        log(`Collision prevented on ${l.id}, reverting.`);\n        l.x = oldX;\n        l.y = oldY;\n        l.moved = false;\n        return layout;\n    }\n\n    // Move each item that collides away from this element.\n    for (let i = 0, len = collisions.length; i < len; i++) {\n        const collision = collisions[i];\n        log(\n            `Resolving collision between ${l.id} at [${l.x},${l.y}] and ${\n                collision.id\n            } at [${collision.x},${collision.y}]`,\n        );\n\n        // Short circuit so we can't infinite loop\n        if (collision.moved) {\n            continue;\n        }\n\n        // Don't move static items - we have to move *this* element away\n        if (collision.static) {\n            layout = moveElementAwayFromCollision(\n                layout,\n                collision,\n                l,\n                isUserAction,\n                compactType,\n                cols,\n            );\n        } else {\n            layout = moveElementAwayFromCollision(\n                layout,\n                l,\n                collision,\n                isUserAction,\n                compactType,\n                cols,\n            );\n        }\n    }\n\n    return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nexport function moveElementAwayFromCollision(\n    layout: Layout,\n    collidesWith: LayoutItem,\n    itemToMove: LayoutItem,\n    isUserAction: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    const compactH = compactType === 'horizontal';\n    // Compact vertically if not set to horizontal\n    const compactV = compactType !== 'horizontal';\n    const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n    // If there is enough space above the collision to put this element, move it there.\n    // We only do this on the main collision as this can get funky in cascades and cause\n    // unwanted swapping behavior.\n    if (isUserAction) {\n        // Reset isUserAction flag because we're not in the main collision anymore.\n        isUserAction = false;\n\n        // Make a mock item so we don't modify the item here, only modify in moveElement.\n        const fakeItem: LayoutItem = {\n            x: compactH\n                ? Math.max(collidesWith.x - itemToMove.w, 0)\n                : itemToMove.x,\n            y: compactV\n                ? Math.max(collidesWith.y - itemToMove.h, 0)\n                : itemToMove.y,\n            w: itemToMove.w,\n            h: itemToMove.h,\n            id: '-1',\n        };\n\n        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n        if (!getFirstCollision(layout, fakeItem)) {\n            log(\n                `Doing reverse collision on ${itemToMove.id} up to [${\n                    fakeItem.x\n                },${fakeItem.y}].`,\n            );\n            return moveElement(\n                layout,\n                itemToMove,\n                compactH ? fakeItem.x : undefined,\n                compactV ? fakeItem.y : undefined,\n                isUserAction,\n                preventCollision,\n                compactType,\n                cols,\n            );\n        }\n    }\n\n    return moveElement(\n        layout,\n        itemToMove,\n        compactH ? itemToMove.x + 1 : undefined,\n        compactV ? itemToMove.y + 1 : undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols,\n    );\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nexport function perc(num: number): string {\n    return num * 100 + '%';\n}\n\nexport function setTransform({top, left, width, height}: Position): Object {\n    // Replace unitless items with px\n    const translate = `translate(${left}px,${top}px)`;\n    return {\n        transform: translate,\n        WebkitTransform: translate,\n        MozTransform: translate,\n        msTransform: translate,\n        OTransform: translate,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'absolute',\n    };\n}\n\nexport function setTopLeft({top, left, width, height}: Position): Object {\n    return {\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'absolute',\n    };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nexport function sortLayoutItems(\n    layout: Layout,\n    compactType: CompactType,\n): Layout {\n    if (compactType === 'horizontal') {\n        return sortLayoutItemsByColRow(layout);\n    } else {\n        return sortLayoutItemsByRowCol(layout);\n    }\n}\n\nexport function sortLayoutItemsByRowCol(layout: Layout): Layout {\n    return ([] as any[]).concat(layout).sort(function (a, b) {\n        if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\n            return 1;\n        } else if (a.y === b.y && a.x === b.x) {\n            // Without this, we can get different sort results in IE vs. Chrome/FF\n            return 0;\n        }\n        return -1;\n    });\n}\n\nexport function sortLayoutItemsByColRow(layout: Layout): Layout {\n    return ([] as any[]).concat(layout).sort(function (a, b) {\n        if (a.x > b.x || (a.x === b.x && a.y > b.y)) {\n            return 1;\n        }\n        return -1;\n    });\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nexport function validateLayout(\n    layout: Layout,\n    contextName: string = 'Layout',\n): void {\n    const subProps = ['x', 'y', 'w', 'h'];\n    if (!Array.isArray(layout)) {\n        throw new Error(contextName + ' must be an array!');\n    }\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const item = layout[i];\n        for (let j = 0; j < subProps.length; j++) {\n            if (typeof item[subProps[j]] !== 'number') {\n                throw new Error(\n                    'ReactGridLayout: ' +\n                    contextName +\n                    '[' +\n                    i +\n                    '].' +\n                    subProps[j] +\n                    ' must be a number!',\n                );\n            }\n        }\n        if (item.id && typeof item.id !== 'string') {\n            throw new Error(\n                'ReactGridLayout: ' +\n                contextName +\n                '[' +\n                i +\n                '].i must be a string!',\n            );\n        }\n        if (item.static !== undefined && typeof item.static !== 'boolean') {\n            throw new Error(\n                'ReactGridLayout: ' +\n                contextName +\n                '[' +\n                i +\n                '].static must be a boolean!',\n            );\n        }\n    }\n}\n\n// Flow can't really figure this out, so we just use Object\nexport function autoBindHandlers(el: Object, fns: Array<string>): void {\n    fns.forEach(key => (el[key] = el[key].bind(el)));\n}\n\nfunction log(...args) {\n    if (!DEBUG) {\n        return;\n    }\n    // eslint-disable-next-line no-console\n    console.log(...args);\n}\n\nexport const noop = () => {};\n","/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents: boolean;\n\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport function ktdSupportsPassiveEventListeners(): boolean {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null!, Object.defineProperty({}, 'passive', {\n                get: () => supportsPassiveEvents = true\n            }));\n        } finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n\n    return supportsPassiveEvents;\n}\n\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nexport function ktdNormalizePassiveListenerOptions(options: AddEventListenerOptions):\n    AddEventListenerOptions | boolean {\n    return ktdSupportsPassiveEventListeners() ? options : !!options.capture;\n}\n","import { fromEvent, iif, merge, Observable } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { ktdNormalizePassiveListenerOptions } from './passive-listeners';\n\n/** Options that can be used to bind a passive event listener. */\nconst passiveEventListenerOptions = ktdNormalizePassiveListenerOptions({passive: true});\n\n/** Options that can be used to bind an active event listener. */\nconst activeEventListenerOptions = ktdNormalizePassiveListenerOptions({passive: false});\n\nlet isMobile: boolean | null = null;\n\nexport function ktdIsMobileOrTablet(): boolean {\n\n    if (isMobile != null) {\n        return isMobile;\n    }\n\n    // Generic match pattern to identify mobile or tablet devices\n    const isMobileDevice = /Android|webOS|BlackBerry|Windows Phone|iPad|iPhone|iPod/i.test(navigator.userAgent);\n\n    // Since IOS 13 is not safe to just check for the generic solution. See: https://stackoverflow.com/questions/58019463/how-to-detect-device-name-in-safari-on-ios-13-while-it-doesnt-show-the-correct\n    const isIOSMobileDevice = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\n\n    isMobile = isMobileDevice || isIOSMobileDevice;\n\n    return isMobile;\n}\n\nexport function ktdIsMouseEvent(event: any): event is MouseEvent {\n    return (event as MouseEvent).clientX != null;\n}\n\nexport function ktdIsTouchEvent(event: any): event is TouchEvent {\n    return (event as TouchEvent).touches != null && (event as TouchEvent).touches.length != null;\n}\n\nexport function ktdPointerClientX(event: MouseEvent | TouchEvent): number {\n    return ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX;\n}\n\nexport function ktdPointerClientY(event: MouseEvent | TouchEvent): number {\n    return ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY;\n}\n\nexport function ktdPointerClient(event: MouseEvent | TouchEvent): {clientX: number, clientY: number} {\n    return  {\n        clientX: ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX,\n        clientY: ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY\n    };\n}\n\n/**\n * Emits when a mousedown or touchstart emits. Avoids conflicts between both events.\n * @param element, html element where to  listen the events.\n * @param touchNumber number of the touch to track the event, default to the first one.\n */\nexport function ktdMouseOrTouchDown(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        fromEvent<TouchEvent>(element, 'touchstart', passiveEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber)\n        ),\n        fromEvent<MouseEvent>(element, 'mousedown', activeEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((mouseEvent: MouseEvent) => {\n                /**\n                 * 0 : Left mouse button\n                 * 1 : Wheel button or middle button (if present)\n                 * 2 : Right mouse button\n                 */\n                return mouseEvent.button === 0; // Mouse down to be only fired if is left click\n            })\n        )\n    );\n}\n\n/**\n * Emits when a 'mousemove' or a 'touchmove' event gets fired.\n * @param element, html element where to  listen the events.\n * @param touchNumber number of the touch to track the event, default to the first one.\n */\nexport function ktdMouseOrTouchMove(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        fromEvent<TouchEvent>(element, 'touchmove', activeEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber),\n        ),\n        fromEvent<MouseEvent>(element, 'mousemove', activeEventListenerOptions as AddEventListenerOptions)\n    );\n}\n\nexport function ktdTouchEnd(element, touchNumber = 1): Observable<TouchEvent> {\n    return merge(\n        fromEvent<TouchEvent>(element, 'touchend').pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)\n        ),\n        fromEvent<TouchEvent>(element, 'touchcancel').pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)\n        )\n    );\n}\n\n/**\n * Emits when a there is a 'mouseup' or the touch ends.\n * @param element, html element where to  listen the events.\n * @param touchNumber number of the touch to track the event, default to the first one.\n */\nexport function ktdMouseOrTouchEnd(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        ktdTouchEnd(element, touchNumber),\n        fromEvent<MouseEvent>(element, 'mouseup'),\n    );\n}\n","import { compact, CompactType, getFirstCollision, Layout, LayoutItem, moveElement } from './react-grid-layout.utils';\nimport { KtdDraggingData, KtdGridCfg, KtdGridCompactType, KtdGridItemRect, KtdGridLayout, KtdGridLayoutItem } from '../grid.definitions';\nimport { ktdPointerClientX, ktdPointerClientY } from './pointer.utils';\nimport { KtdDictionary } from '../../types';\n\n/** Tracks items by id. This function is mean to be used in conjunction with the ngFor that renders the 'ktd-grid-items' */\nexport function ktdTrackById(index: number, item: {id: string}) {\n    return item.id;\n}\n\n/**\n * Call react-grid-layout utils 'compact()' function and return the compacted layout.\n * @param layout to be compacted.\n * @param compactType, type of compaction.\n * @param cols, number of columns of the grid.\n */\nexport function ktdGridCompact(layout: KtdGridLayout, compactType: KtdGridCompactType, cols: number): KtdGridLayout {\n    return compact(layout, compactType, cols)\n        // Prune react-grid-layout compact extra properties.\n        .map(item => ({id: item.id, x: item.x, y: item.y, w: item.w, h: item.h}));\n}\n\nfunction screenXPosToGridValue(screenXPos: number, cols: number, width: number): number {\n    return Math.round((screenXPos * cols) / width);\n}\n\nfunction screenYPosToGridValue(screenYPos: number, rowHeight: number, height: number): number {\n    return Math.round(screenYPos / rowHeight);\n}\n\n/** Returns a Dictionary where the key is the id and the value is the change applied to that item. If no changes Dictionary is empty. */\nexport function ktdGetGridLayoutDiff(gridLayoutA: KtdGridLayoutItem[], gridLayoutB: KtdGridLayoutItem[]): KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> {\n    const diff: KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> = {};\n\n    gridLayoutA.forEach(itemA => {\n        const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\n        if (itemB != null) {\n            const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\n            const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\n            const change: 'move' | 'resize' | 'moveresize' | null = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\n            if (change) {\n                diff[itemB.id] = {change};\n            }\n        }\n    });\n    return diff;\n}\n\n/**\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\n * @param gridItemId id of the grid item that is been dragged\n * @param config current grid configuration\n * @param compactionType type of compaction that will be performed\n * @param draggingData contains all the information about the drag\n */\nexport function ktdGridItemDragging(gridItemId: string, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n    const offsetX = clientStartX - dragElemClientRect.left;\n    const offsetY = clientStartY - dragElemClientRect.top;\n\n    // Grid element positions taking into account the possible scroll total difference from the beginning.\n    const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\n    const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top;\n\n    // Calculate position relative to the grid element.\n    const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\n    const gridRelYPos = clientY - gridElementTopPosition - offsetY;\n\n    // Get layout item position\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width),\n        y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height)\n    };\n\n    // Correct the values if they overflow, since 'moveElement' function doesn't do it\n    layoutItem.x = Math.max(0, layoutItem.x);\n    layoutItem.y = Math.max(0, layoutItem.y);\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.x = Math.max(0, config.cols - layoutItem.w);\n    }\n\n    // Parse to LayoutItem array data in order to use 'react.grid-layout' utils\n    const layoutItems: LayoutItem[] = config.layout;\n    const draggedLayoutItem: LayoutItem = layoutItems.find(item => item.id === gridItemId)!;\n\n    let newLayoutItems: LayoutItem[] = moveElement(\n        layoutItems,\n        draggedLayoutItem,\n        layoutItem.x,\n        layoutItem.y,\n        true,\n        config.preventCollision,\n        compactionType,\n        config.cols\n    );\n\n    newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\n\n    return {\n        layout: newLayoutItems,\n        draggedItemPos: {\n            top: gridRelYPos,\n            left: gridRelXPos,\n            width: dragElemClientRect.width,\n            height: dragElemClientRect.height,\n        }\n    };\n}\n\n/**\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\n * @param gridItemId id of the grid item that is been dragged\n * @param config current grid configuration\n * @param compactionType type of compaction that will be performed\n * @param draggingData contains all the information about the drag\n */\nexport function ktdGridItemResizing(gridItemId: string, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n    // Get the difference between the mouseDown and the position 'right' of the resize element.\n    const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\n    const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n    const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\n    const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top);\n\n\n    // Get layout item grid position\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width),\n        h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height)\n    };\n\n    layoutItem.w = Math.max(1, layoutItem.w);\n    layoutItem.h = Math.max(1, layoutItem.h);\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.w = Math.max(1, config.cols - layoutItem.x);\n    }\n\n    if (config.preventCollision) {\n        const maxW = layoutItem.w;\n        const maxH = layoutItem.h;\n\n        let colliding = hasCollision(config.layout, layoutItem);\n        let shrunkDimension: 'w' | 'h' | undefined;\n\n        while (colliding) {\n            shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\n            layoutItem[shrunkDimension]--;\n            colliding = hasCollision(config.layout, layoutItem);\n        }\n\n        if (shrunkDimension === 'w') {\n            layoutItem.h = maxH;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.h--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n        if (shrunkDimension === 'h') {\n            layoutItem.w = maxW;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.w--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n\n    }\n\n    const newLayoutItems: LayoutItem[] = config.layout.map((item) => {\n        return item.id === gridItemId ? layoutItem : item;\n    });\n\n    return {\n        layout: compact(newLayoutItems, compactionType, config.cols),\n        draggedItemPos: {\n            top: dragElemClientRect.top - gridElemClientRect.top,\n            left: dragElemClientRect.left - gridElemClientRect.left,\n            width,\n            height,\n        }\n    };\n}\n\nfunction hasCollision(layout: Layout, layoutItem: LayoutItem): boolean {\n    return !!getFirstCollision(layout, layoutItem);\n}\n\nfunction getDimensionToShrink(layoutItem, lastShrunk): 'w' | 'h' {\n    if (layoutItem.h <= 1) {\n        return 'w';\n    }\n    if (layoutItem.w <= 1) {\n        return 'h';\n    }\n\n    return lastShrunk === 'w' ? 'h' : 'w';\n}\n","import { Directive, ElementRef, InjectionToken } from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `KtdGridDragHandle`. It serves as\n * alternative token to the actual `KtdGridDragHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const KTD_GRID_DRAG_HANDLE = new InjectionToken<KtdGridDragHandle>('KtdGridDragHandle');\n\n/** Handle that can be used to drag a KtdGridItem instance. */\n@Directive({\n    selector: '[ktdGridDragHandle]',\n    host: {\n        class: 'ktd-grid-drag-handle'\n    },\n    providers: [{provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle}],\n})\n// tslint:disable-next-line:directive-class-suffix\nexport class KtdGridDragHandle {\n    constructor(\n        public element: ElementRef<HTMLElement>) {\n    }\n}\n","import { Directive, ElementRef, InjectionToken, } from '@angular/core';\n\n\n/**\n * Injection token that can be used to reference instances of `KtdGridResizeHandle`. It serves as\n * alternative token to the actual `KtdGridResizeHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const KTD_GRID_RESIZE_HANDLE = new InjectionToken<KtdGridResizeHandle>('KtdGridResizeHandle');\n\n/** Handle that can be used to drag a KtdGridItem instance. */\n@Directive({\n    selector: '[ktdGridResizeHandle]',\n    host: {\n        class: 'ktd-grid-resize-handle'\n    },\n    providers: [{provide: KTD_GRID_RESIZE_HANDLE, useExisting: KtdGridResizeHandle}],\n})\nexport class KtdGridResizeHandle {\n\n    constructor(\n        public element: ElementRef<HTMLElement>) {\n    }\n}\n","import { InjectionToken } from '@angular/core';\nimport { CompactType } from './utils/react-grid-layout.utils';\n\nexport interface KtdGridLayoutItem {\n    id: string;\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    content?: Widget;\n    idItem?: number;\n    hierarchyId?: number;\n}\n\nexport type KtdGridCompactType = CompactType;\n\nexport interface KtdGridCfg {\n    cols: number;\n    rowHeight: number; // row height in pixels\n    layout: KtdGridLayoutItem[];\n    preventCollision: boolean;\n}\n\nexport type KtdGridLayout = KtdGridLayoutItem[];\n\n// TODO: Remove this interface. If can't remove, move and rename this interface in the core module or similar.\nexport interface KtdGridItemRect {\n    top: number;\n    left: number;\n    width: number;\n    height: number;\n}\n\nexport interface KtdGridItemRenderData<T = number | string> {\n    id: string;\n    top: T;\n    left: T;\n    width: T;\n    height: T;\n    content?: Widget;\n}\nexport interface Widget {\n    id: number;\n    name: string;\n    content: string;\n    idLayout: string;\n    show: boolean;\n    size: number;\n    hierarchyId: number;\n}\n\n/**\n * We inject a token because of the 'circular dependency issue warning'. In case we don't had this issue with the circular dependency, we could just\n * import KtdGridComponent on KtdGridItem and execute the needed function to get the rendering data.\n */\nexport type KtdGridItemRenderDataTokenType = (id: string) => KtdGridItemRenderData<string>;\nexport const GRID_ITEM_GET_RENDER_DATA_TOKEN: InjectionToken<KtdGridItemRenderDataTokenType> = new InjectionToken('GRID_ITEM_GET_RENDER_DATA_TOKEN');\n\nexport interface KtdDraggingData {\n    pointerDownEvent: MouseEvent | TouchEvent;\n    pointerDragEvent: MouseEvent | TouchEvent;\n    gridElemClientRect: ClientRect;\n    dragElemClientRect: ClientRect;\n    scrollDifference: { top: number, left: number };\n}\n","// tslint:disable\n/**\n * Type describing the allowed values for a boolean input.\n * @docs-private\n */\nexport type BooleanInput = string | boolean | null | undefined;\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\nexport function coerceBooleanProperty(value: any): boolean {\n  return value != null && `${value}` !== 'false';\n}\n","// tslint:disable\nexport type NumberInput = string | number | null | undefined;\n\n/** Coerces a data-bound value (typically a string) to a number. */\nexport function coerceNumberProperty(value: any): number;\nexport function coerceNumberProperty<D>(value: any, fallback: D): number | D;\nexport function coerceNumberProperty(value: any, fallbackValue = 0) {\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nexport function _isNumberValue(value: any): boolean {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(value as any)) && !isNaN(Number(value));\n}\n","import { Injectable, NgZone, OnDestroy } from '@angular/core';\nimport { ktdNormalizePassiveListenerOptions } from './utils/passive-listeners';\nimport { fromEvent, iif, Observable, Subject, Subscription } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { ktdIsMobileOrTablet } from './utils/pointer.utils';\n\n/** Event options that can be used to bind an active, capturing event. */\nconst activeCapturingEventOptions = ktdNormalizePassiveListenerOptions({\n    passive: false,\n    capture: true\n});\n\n@Injectable({providedIn: 'root'})\nexport class KtdGridService implements OnDestroy {\n\n    touchMove$: Observable<TouchEvent>;\n    private touchMoveSubject: Subject<TouchEvent> = new Subject<TouchEvent>();\n    private touchMoveSubscription: Subscription;\n\n    constructor(private ngZone: NgZone) {\n        this.touchMove$ = this.touchMoveSubject.asObservable();\n        this.registerTouchMoveSubscription();\n    }\n\n    ngOnDestroy() {\n        this.touchMoveSubscription.unsubscribe();\n    }\n\n    mouseOrTouchMove$(element): Observable<MouseEvent | TouchEvent> {\n        return iif(\n            () => ktdIsMobileOrTablet(),\n            this.touchMove$,\n            fromEvent<MouseEvent>(element, 'mousemove', activeCapturingEventOptions as AddEventListenerOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n        );\n    }\n\n    private registerTouchMoveSubscription() {\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        this.touchMoveSubscription = this.ngZone.runOutsideAngular(() =>\n            // The event handler has to be explicitly active,\n            // because newer browsers make it passive by default.\n            fromEvent(document, 'touchmove', activeCapturingEventOptions as AddEventListenerOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n                .pipe(filter((touchEvent: TouchEvent) => touchEvent.touches.length === 1))\n                .subscribe((touchEvent: TouchEvent) => this.touchMoveSubject.next(touchEvent))\n        );\n    }\n}\n","import {\n    AfterContentInit, ChangeDetectionStrategy, Component, ContentChildren, ElementRef, Inject, Input, NgZone, OnDestroy, OnInit, QueryList, Renderer2,\n    ViewChild\n} from '@angular/core';\nimport { BehaviorSubject, iif, merge, NEVER, Observable, Subject, Subscription } from 'rxjs';\nimport { exhaustMap, filter, map, startWith, switchMap, take, takeUntil } from 'rxjs/operators';\nimport { ktdMouseOrTouchDown, ktdMouseOrTouchEnd, ktdPointerClient } from '../utils/pointer.utils';\nimport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KtdGridItemRenderDataTokenType } from '../grid.definitions';\nimport { KTD_GRID_DRAG_HANDLE, KtdGridDragHandle } from '../directives/drag-handle';\nimport { KTD_GRID_RESIZE_HANDLE, KtdGridResizeHandle } from '../directives/resize-handle';\nimport { KtdGridService } from '../grid.service';\nimport { ktdOutsideZone } from '../utils/operators';\nimport { BooleanInput, coerceBooleanProperty } from '../coercion/boolean-property';\nimport { coerceNumberProperty, NumberInput } from '../coercion/number-property';\n\n@Component({\n    selector: 'ktd-grid-item',\n    templateUrl: './grid-item.component.html',\n    styleUrls: ['./grid-item.component.scss'],\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class KtdGridItemComponent implements OnInit, OnDestroy, AfterContentInit {\n    /** Elements that can be used to drag the grid item. */\n    @ContentChildren(KTD_GRID_DRAG_HANDLE, {descendants: true}) _dragHandles: QueryList<KtdGridDragHandle>;\n    @ContentChildren(KTD_GRID_RESIZE_HANDLE, {descendants: true}) _resizeHandles: QueryList<KtdGridResizeHandle>;\n    @ViewChild('resizeElem', {static: true, read: ElementRef}) resizeElem: ElementRef;\n\n    /** CSS transition style. Note that for more performance is preferable only make transition on transform property. */\n    @Input() transition: string = 'transform 500ms ease, width 500ms ease, height 500ms ease';\n\n    dragStart$: Observable<MouseEvent | TouchEvent>;\n    resizeStart$: Observable<MouseEvent | TouchEvent>;\n\n    /** Id of the grid item. This property is strictly compulsory. */\n    @Input()\n    get id(): string {\n        return this._id;\n    }\n\n    set id(val: string) {\n        this._id = val;\n    }\n\n    private _id: string;\n\n    /** Minimum amount of pixels that the user should move before it starts the drag sequence. */\n    @Input()\n    get dragStartThreshold(): number { return this._dragStartThreshold; }\n\n    set dragStartThreshold(val: number) {\n        this._dragStartThreshold = coerceNumberProperty(val);\n    }\n\n    private _dragStartThreshold: number = 0;\n\n\n    /** Whether the item is draggable or not. Defaults to true. */\n    @Input()\n    get draggable(): boolean {\n        return this._draggable;\n    }\n\n    set draggable(val: boolean) {\n        this._draggable = coerceBooleanProperty(val);\n        this._draggable$.next(this._draggable);\n    }\n\n    private _draggable: boolean = true;\n    private _draggable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._draggable);\n\n    /** Whether the item is resizable or not. Defaults to true. */\n    @Input()\n    get resizable(): boolean {\n        return this._resizable;\n    }\n\n    set resizable(val: boolean) {\n        this._resizable = coerceBooleanProperty(val);\n        this._resizable$.next(this._resizable);\n    }\n\n    private _resizable: boolean = true;\n    private _resizable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._resizable);\n\n    private dragStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n    private resizeStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n\n    private subscriptions: Subscription[] = [];\n\n    constructor(public elementRef: ElementRef,\n                private gridService: KtdGridService,\n                private renderer: Renderer2,\n                private ngZone: NgZone,\n                @Inject(GRID_ITEM_GET_RENDER_DATA_TOKEN) private getItemRenderData: KtdGridItemRenderDataTokenType) {\n        this.dragStart$ = this.dragStartSubject.asObservable();\n        this.resizeStart$ = this.resizeStartSubject.asObservable();\n    }\n\n    ngOnInit() {\n        const gridItemRenderData = this.getItemRenderData(this.id)!;\n        this.setStyles(gridItemRenderData);\n    }\n\n    ngAfterContentInit() {\n        this.subscriptions.push(\n            this._dragStart$().subscribe(this.dragStartSubject),\n            this._resizeStart$().subscribe(this.resizeStartSubject),\n        );\n    }\n\n    ngOnDestroy() {\n        this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    setStyles({top, left, width, height}: { top: string, left: string, width?: string, height?: string }) {\n        // transform is 6x times faster than top/left\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\n        if (width != null) { this.renderer.setStyle(this.elementRef.nativeElement, 'width', width); }\n        if (height != null) {this.renderer.setStyle(this.elementRef.nativeElement, 'height', height); }\n    }\n\n    private _dragStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._draggable$.pipe(\n            switchMap((draggable) => {\n                if (!draggable) {\n                    return NEVER;\n                } else {\n                    return this._dragHandles.changes.pipe(\n                        startWith(this._dragHandles),\n                        switchMap((dragHandles: QueryList<KtdGridDragHandle>) => {\n                            return iif(\n                                () => dragHandles.length > 0,\n                                merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))),\n                                ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)\n                            ).pipe(\n                                exhaustMap((startEvent) => {\n                                    // If the event started from an element with the native HTML drag&drop, it'll interfere\n                                    // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n                                    // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n                                    // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n                                    // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n                                    // events from firing on touch devices.\n                                    if (startEvent.target && (startEvent.target as HTMLElement).draggable && startEvent.type === 'mousedown') {\n                                        startEvent.preventDefault();\n                                    }\n\n                                    const startPointer = ktdPointerClient(startEvent);\n                                    return this.gridService.mouseOrTouchMove$(document).pipe(\n                                        takeUntil(ktdMouseOrTouchEnd(document, 1)),\n                                        ktdOutsideZone(this.ngZone),\n                                        filter((moveEvent) => {\n                                            moveEvent.preventDefault();\n                                            const movePointer = ktdPointerClient(moveEvent);\n                                            const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\n                                            const distanceY = Math.abs(startPointer.clientY - movePointer.clientY);\n                                            // When this conditions returns true mean that we are over threshold.\n                                            return distanceX + distanceY >= this.dragStartThreshold;\n                                        }),\n                                        take(1),\n                                        // Return the original start event\n                                        map(() => startEvent)\n                                    );\n                                })\n                            );\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n    private _resizeStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._resizable$.pipe(\n            switchMap((resizable) => {\n                if (!resizable) {\n                    // Side effect to hide the resizeElem if resize is disabled.\n                    this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                    return NEVER;\n                } else {\n                    return this._resizeHandles.changes.pipe(\n                        startWith(this._resizeHandles),\n                        switchMap((resizeHandles: QueryList<KtdGridResizeHandle>) => {\n                            if (resizeHandles.length > 0) {\n                                // Side effect to hide the resizeElem if there are resize handles.\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                                return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\n                            } else {\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\n                                return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\n                            }\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n\n    // tslint:disable-next-line\n    static ngAcceptInputType_draggable: BooleanInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_resizable: BooleanInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_dragStartThreshold: NumberInput;\n\n}\n","import { NgZone } from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n/** Runs source observable outside the zone */\nexport function ktdOutsideZone<T>(zone: NgZone) {\n    return (source: Observable<T>) => {\n        return new Observable<T>(observer => {\n            return zone.runOutsideAngular<Subscription>(() => source.subscribe(observer));\n        });\n    };\n}\n\n\n/** Rxjs operator that makes source observable to no emit any data */\nexport function ktdNoEmit() {\n    return (source$: Observable<any>): Observable<any> => {\n        return source$.pipe(filter(() => false));\n    };\n}\n","\n// tslint:disable\n\n/**\n * Client rect utilities.\n * This file is taken from Angular Material repository. This is the reason why the tslint is disabled on this case.\n * Don't enable it until some custom change is done on this file.\n */\n\n\n/** Gets a mutable version of an element's bounding `ClientRect`. */\nexport function getMutableClientRect(element: Element): ClientRect {\n  const clientRect = element.getBoundingClientRect();\n\n  // We need to clone the `clientRect` here, because all the values on it are readonly\n  // and we need to be able to update them. Also we can't use a spread here, because\n  // the values on a `ClientRect` aren't own properties. See:\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n  return {\n    top: clientRect.top,\n    right: clientRect.right,\n    bottom: clientRect.bottom,\n    left: clientRect.left,\n    width: clientRect.width,\n    height: clientRect.height\n  };\n}\n\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param clientRect ClientRect that is being checked.\n * @param x Coordinates along the X axis.\n * @param y Coordinates along the Y axis.\n */\nexport function isInsideClientRect(clientRect: ClientRect, x: number, y: number) {\n  const {top, bottom, left, right} = clientRect;\n  return y >= top && y <= bottom && x >= left && x <= right;\n}\n\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param clientRect `ClientRect` that should be updated.\n * @param top Amount to add to the `top` position.\n * @param left Amount to add to the `left` position.\n */\nexport function adjustClientRect(clientRect: ClientRect, top: number, left: number) {\n  clientRect.top += top;\n  clientRect.bottom = clientRect.top + clientRect.height;\n\n  clientRect.left += left;\n  clientRect.right = clientRect.left + clientRect.width;\n}\n\n/**\n * Checks whether the pointer coordinates are close to a ClientRect.\n * @param rect ClientRect to check against.\n * @param threshold Threshold around the ClientRect.\n * @param pointerX Coordinates along the X axis.\n * @param pointerY Coordinates along the Y axis.\n */\nexport function isPointerNearClientRect(rect: ClientRect,\n                                        threshold: number,\n                                        pointerX: number,\n                                        pointerY: number): boolean {\n  const {top, right, bottom, left, width, height} = rect;\n  const xThreshold = width * threshold;\n  const yThreshold = height * threshold;\n\n  return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n         pointerX > left - xThreshold && pointerX < right + xThreshold;\n}\n","<ng-content></ng-content>\n<div #resizeElem class=\"grid-item-resize-icon\"></div>\n","import { animationFrameScheduler, fromEvent, interval, NEVER, Observable } from 'rxjs';\nimport { distinctUntilChanged, map, switchMap, tap } from 'rxjs/operators';\nimport { ktdNormalizePassiveListenerOptions } from './passive-listeners';\nimport { getMutableClientRect } from './client-rect';\nimport { ktdNoEmit } from './operators';\n\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling.\n * The value comes from trying it out manually until it feels right.\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n\n/** Vertical direction in which we can auto-scroll. */\nconst enum AutoScrollVerticalDirection {NONE, UP, DOWN}\n\n/** Horizontal direction in which we can auto-scroll. */\nconst enum AutoScrollHorizontalDirection {NONE, LEFT, RIGHT}\n\nexport interface KtdScrollPosition {\n    top: number;\n    left: number;\n}\n\n\n/**\n * Increments the vertical scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementVerticalScroll(node: HTMLElement | Window, amount: number) {\n    if (node === window) {\n        (node as Window).scrollBy(0, amount);\n    } else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        (node as HTMLElement).scrollTop += amount;\n    }\n}\n\n/**\n * Increments the horizontal scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementHorizontalScroll(node: HTMLElement | Window, amount: number) {\n    if (node === window) {\n        (node as Window).scrollBy(amount, 0);\n    } else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        (node as HTMLElement).scrollLeft += amount;\n    }\n}\n\n\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getVerticalScrollDirection(clientRect: ClientRect, pointerY: number) {\n    const {top, bottom, height} = clientRect;\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return AutoScrollVerticalDirection.UP;\n    } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return AutoScrollVerticalDirection.DOWN;\n    }\n\n    return AutoScrollVerticalDirection.NONE;\n}\n\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerX Position of the user's pointer along the x axis.\n */\nfunction getHorizontalScrollDirection(clientRect: ClientRect, pointerX: number) {\n    const {left, right, width} = clientRect;\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return AutoScrollHorizontalDirection.LEFT;\n    } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return AutoScrollHorizontalDirection.RIGHT;\n    }\n\n    return AutoScrollHorizontalDirection.NONE;\n}\n\n/**\n * Returns an observable that schedules a loop and apply scroll on the scrollNode into the specified direction/s.\n * This observable doesn't emit, it just performs the 'scroll' side effect.\n * @param scrollNode, node where the scroll would be applied.\n * @param verticalScrollDirection, vertical direction of the scroll.\n * @param horizontalScrollDirection, horizontal direction of the scroll.\n * @param scrollStep, scroll step in CSS pixels that would be applied in every loop.\n */\nfunction scrollToDirectionInterval$(scrollNode: HTMLElement | Window, verticalScrollDirection: AutoScrollVerticalDirection, horizontalScrollDirection: AutoScrollHorizontalDirection, scrollStep: number = 2) {\n    return interval(0, animationFrameScheduler)\n        .pipe(\n            tap(() => {\n                if (verticalScrollDirection === AutoScrollVerticalDirection.UP) {\n                    incrementVerticalScroll(scrollNode, -scrollStep);\n                } else if (verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {\n                    incrementVerticalScroll(scrollNode, scrollStep);\n                }\n\n                if (horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {\n                    incrementHorizontalScroll(scrollNode, -scrollStep);\n                } else if (horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {\n                    incrementHorizontalScroll(scrollNode, scrollStep);\n                }\n            }),\n            ktdNoEmit()\n        );\n}\n\nexport interface KtdScrollIfNearElementOptions {\n    scrollStep?: number;\n    disableVertical?: boolean;\n    disableHorizontal?: boolean;\n}\n\n/**\n * Given a source$ observable with pointer location, scroll the scrollNode if the pointer is near to it.\n * This observable doesn't emit, it just performs a 'scroll' side effect.\n * @param scrollableParent, parent node in which the scroll would be performed.\n * @param options, configuration options.\n */\nexport function ktdScrollIfNearElementClientRect$(scrollableParent: HTMLElement | Document, options?: KtdScrollIfNearElementOptions): (source$: Observable<{ pointerX: number, pointerY: number }>) => Observable<any> {\n\n    let scrollNode: Window | HTMLElement;\n    let scrollableParentClientRect: ClientRect;\n    let scrollableParentScrollWidth: number;\n\n    if (scrollableParent === document) {\n        scrollNode = document.defaultView as Window;\n        const {width, height} = getViewportSize();\n        scrollableParentClientRect = {width, height, top: 0, right: width, bottom: height, left: 0};\n        scrollableParentScrollWidth = getDocumentScrollWidth();\n    } else {\n        scrollNode = scrollableParent as HTMLElement;\n        scrollableParentClientRect = getMutableClientRect(scrollableParent as HTMLElement);\n        scrollableParentScrollWidth = (scrollableParent as HTMLElement).scrollWidth;\n    }\n\n    /**\n     * IMPORTANT: By design, only let scroll horizontal if the scrollable parent has explicitly an scroll horizontal.\n     * This layout solution is not designed in mind to have any scroll horizontal, but exceptionally we allow it in this\n     * specific use case.\n     */\n    options = options || {};\n    if (options.disableHorizontal == null && scrollableParentScrollWidth <= scrollableParentClientRect.width) {\n        options.disableHorizontal = true;\n    }\n\n    return (source$) => source$.pipe(\n        map(({pointerX, pointerY}) => {\n            let verticalScrollDirection = getVerticalScrollDirection(scrollableParentClientRect, pointerY);\n            let horizontalScrollDirection = getHorizontalScrollDirection(scrollableParentClientRect, pointerX);\n\n            // Check if scroll directions are disabled.\n            if (options?.disableVertical) {\n                verticalScrollDirection = AutoScrollVerticalDirection.NONE;\n            }\n            if (options?.disableHorizontal) {\n                horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;\n            }\n\n            return {verticalScrollDirection, horizontalScrollDirection};\n        }),\n        distinctUntilChanged((prev, actual) => {\n            return prev.verticalScrollDirection === actual.verticalScrollDirection\n                && prev.horizontalScrollDirection === actual.horizontalScrollDirection;\n        }),\n        switchMap(({verticalScrollDirection, horizontalScrollDirection}) => {\n            if (verticalScrollDirection || horizontalScrollDirection) {\n                return scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, options?.scrollStep);\n            } else {\n                return NEVER;\n            }\n        })\n    );\n}\n\n/**\n * Emits on EVERY scroll event and returns the accumulated scroll offset relative to the initial scroll position.\n * @param scrollableParent, node in which scroll events would be listened.\n */\nexport function ktdGetScrollTotalRelativeDifference$(scrollableParent: HTMLElement | Document): Observable<{ top: number, left: number }> {\n    let scrollInitialPosition;\n\n    // Calculate initial scroll position\n    if (scrollableParent === document) {\n        scrollInitialPosition = getViewportScrollPosition();\n    } else {\n        scrollInitialPosition = {\n            top: (scrollableParent as HTMLElement).scrollTop,\n            left: (scrollableParent as HTMLElement).scrollLeft\n        };\n    }\n\n    return fromEvent(scrollableParent, 'scroll', ktdNormalizePassiveListenerOptions({capture: true}) as AddEventListenerOptions).pipe(\n        map(() => {\n            let newTop: number;\n            let newLeft: number;\n\n            if (scrollableParent === document) {\n                const viewportScrollPosition = getViewportScrollPosition();\n                newTop = viewportScrollPosition.top;\n                newLeft = viewportScrollPosition.left;\n            } else {\n                newTop = (scrollableParent as HTMLElement).scrollTop;\n                newLeft = (scrollableParent as HTMLElement).scrollLeft;\n            }\n\n            const topDifference = scrollInitialPosition.top - newTop;\n            const leftDifference = scrollInitialPosition.left - newLeft;\n\n            return {top: topDifference, left: leftDifference};\n        })\n    );\n\n}\n\n/** Returns the viewport's width and height. */\nfunction getViewportSize(): { width: number, height: number } {\n    const _window = document.defaultView || window;\n    return {\n        width: _window.innerWidth,\n        height: _window.innerHeight\n    };\n\n}\n\n/** Gets a ClientRect for the viewport's bounds. */\nfunction getViewportRect(): ClientRect {\n    // Use the document element's bounding rect rather than the window scroll properties\n    // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n    // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n    // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n    // can disagree when the page is pinch-zoomed (on devices that support touch).\n    // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n    // We use the documentElement instead of the body because, by default (without a css reset)\n    // browsers typically give the document body an 8px margin, which is not included in\n    // getBoundingClientRect().\n    const scrollPosition = getViewportScrollPosition();\n    const {width, height} = getViewportSize();\n\n    return {\n        top: scrollPosition.top,\n        left: scrollPosition.left,\n        bottom: scrollPosition.top + height,\n        right: scrollPosition.left + width,\n        height,\n        width,\n    };\n}\n\n/** Gets the (top, left) scroll position of the viewport. */\nfunction getViewportScrollPosition(): { top: number, left: number } {\n\n    // The top-left-corner of the viewport is determined by the scroll position of the document\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n    // `document.documentElement` works consistently, where the `top` and `left` values will\n    // equal negative the scroll position.\n    const windowRef = document.defaultView || window;\n    const documentElement = document.documentElement!;\n    const documentRect = documentElement.getBoundingClientRect();\n\n    const top = -documentRect.top || document.body.scrollTop || windowRef.scrollY ||\n        documentElement.scrollTop || 0;\n\n    const left = -documentRect.left || document.body.scrollLeft || windowRef.scrollX ||\n        documentElement.scrollLeft || 0;\n\n    return {top, left};\n}\n\n/** Returns the document scroll width */\nfunction getDocumentScrollWidth() {\n    return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n}\n\n","import {\n    AfterContentChecked, AfterContentInit, ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, Input, NgZone, OnChanges,\n    OnDestroy, Output, QueryList, Renderer2, SimpleChanges, ViewEncapsulation\n} from '@angular/core';\nimport { coerceNumberProperty, NumberInput } from './coercion/number-property';\nimport { KtdGridItemComponent } from './grid-item/grid-item.component';\nimport { combineLatest, merge, NEVER, Observable, Observer, of, Subscription } from 'rxjs';\nimport { exhaustMap, map, startWith, switchMap, takeUntil } from 'rxjs/operators';\nimport { ktdGridItemDragging, ktdGridItemResizing } from './utils/grid.utils';\nimport { compact, CompactType } from './utils/react-grid-layout.utils';\nimport {\n    GRID_ITEM_GET_RENDER_DATA_TOKEN, KtdDraggingData, KtdGridCfg, KtdGridCompactType, KtdGridItemRect, KtdGridItemRenderData, KtdGridLayout,\n    KtdGridLayoutItem\n} from './grid.definitions';\nimport { ktdMouseOrTouchEnd, ktdPointerClientX, ktdPointerClientY } from './utils/pointer.utils';\nimport { KtdDictionary } from '../types';\nimport { KtdGridService } from './grid.service';\nimport { getMutableClientRect } from './utils/client-rect';\nimport { ktdGetScrollTotalRelativeDifference$, ktdScrollIfNearElementClientRect$ } from './utils/scroll';\nimport { BooleanInput, coerceBooleanProperty } from './coercion/boolean-property';\n\ninterface KtdDragResizeEvent {\n    layout: KtdGridLayout;\n    layoutItem: KtdGridLayoutItem;\n    gridItemRef: KtdGridItemComponent;\n}\n\nexport type KtdDragStart = KtdDragResizeEvent;\nexport type KtdResizeStart = KtdDragResizeEvent;\nexport type KtdDragEnd = KtdDragResizeEvent;\nexport type KtdResizeEnd = KtdDragResizeEvent;\n\nfunction getDragResizeEventData(gridItem: KtdGridItemComponent, layout: KtdGridLayout): KtdDragResizeEvent {\n    return {\n        layout,\n        layoutItem: layout.find((item) => item.id === gridItem.id)!,\n        gridItemRef: gridItem\n    };\n}\n\n\nfunction layoutToRenderItems(config: KtdGridCfg, width: number, height: number): KtdDictionary<KtdGridItemRenderData<number>> {\n    const {cols, rowHeight, layout} = config;\n\n    const renderItems: KtdDictionary<KtdGridItemRenderData<number>> = {};\n    for (const item of layout) {\n        renderItems[item.id] = {\n            id: item.id,\n            top: item.y === 0 ? 0 : item.y * rowHeight,\n            left: item.x * (width / cols),\n            width: item.w * (width / cols),\n            height: item.h * rowHeight\n        };\n    }\n    return renderItems;\n}\n\nfunction getGridHeight(layout: KtdGridLayout, rowHeight: number): number {\n    return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight), 0);\n}\n\n// tslint:disable-next-line\nexport function parseRenderItemToPixels(renderItem: KtdGridItemRenderData<number>): KtdGridItemRenderData<string> {\n    return {\n        id: renderItem.id,\n        top: `${renderItem.top}px`,\n        left: `${renderItem.left}px`,\n        width: `${renderItem.width}px`,\n        height: `${renderItem.height}px`\n    };\n}\n\n// tslint:disable-next-line:ktd-prefix-code\nexport function __gridItemGetRenderDataFactoryFunc(gridCmp: KtdGridComponent) {\n    // tslint:disable-next-line:only-arrow-functions\n    return function(id: string) {\n        return parseRenderItemToPixels(gridCmp.getItemRenderData(id));\n    };\n}\n\nexport function ktdGridItemGetRenderDataFactoryFunc(gridCmp: KtdGridComponent) {\n    // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613\n    const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);\n    return resultFunc;\n}\n\n\n@Component({\n    selector: 'ktd-grid',\n    templateUrl: './grid.component.html',\n    styleUrls: ['./grid.component.scss'],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [\n        {\n            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\n            useFactory: ktdGridItemGetRenderDataFactoryFunc,\n            deps: [KtdGridComponent]\n        }\n    ]\n})\nexport class KtdGridComponent implements OnChanges, AfterContentInit, AfterContentChecked, OnDestroy {\n    /** Query list of grid items that are being rendered. */\n    @ContentChildren(KtdGridItemComponent, {descendants: true}) _gridItems: QueryList<KtdGridItemComponent>;\n\n    /** Emits when layout change */\n    @Output() layoutUpdated: EventEmitter<KtdGridLayout> = new EventEmitter<KtdGridLayout>();\n\n    /** Emits when drag starts */\n    @Output() dragStarted: EventEmitter<KtdDragStart> = new EventEmitter<KtdDragStart>();\n\n    /** Emits when resize starts */\n    @Output() resizeStarted: EventEmitter<KtdResizeStart> = new EventEmitter<KtdResizeStart>();\n\n    /** Emits when drag ends */\n    @Output() dragEnded: EventEmitter<KtdDragEnd> = new EventEmitter<KtdDragEnd>();\n\n    /** Emits when resize ends */\n    @Output() resizeEnded: EventEmitter<KtdResizeEnd> = new EventEmitter<KtdResizeEnd>();\n\n    /**\n     * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.\n     * If no data provided or null autoscroll is not performed.\n     */\n    @Input() scrollableParent: HTMLElement | Document | string | null = null;\n\n    /** Whether or not to update the internal layout when some dependent property change. */\n    @Input()\n    get compactOnPropsChange(): boolean { return this._compactOnPropsChange; }\n\n    set compactOnPropsChange(value: boolean) {\n        this._compactOnPropsChange = coerceBooleanProperty(value);\n    }\n\n    private _compactOnPropsChange: boolean = true;\n\n    /** If true, grid items won't change position when being dragged over. Handy when using no compaction */\n    @Input()\n    get preventCollision(): boolean { return this._preventCollision; }\n\n    set preventCollision(value: boolean) {\n        this._preventCollision = coerceBooleanProperty(value);\n    }\n\n    private _preventCollision: boolean = false;\n\n    /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */\n    @Input()\n    get scrollSpeed(): number { return this._scrollSpeed; }\n\n    set scrollSpeed(value: number) {\n        this._scrollSpeed = coerceNumberProperty(value, 2);\n    }\n\n    private _scrollSpeed: number = 2;\n\n    /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */\n    @Input()\n    get compactType(): KtdGridCompactType {\n        return this._compactType;\n    }\n\n    set compactType(val: KtdGridCompactType) {\n        this._compactType = val;\n    }\n\n    private _compactType: KtdGridCompactType = 'vertical';\n\n    /** Row height in css pixels */\n    @Input()\n    get rowHeight(): number { return this._rowHeight; }\n\n    set rowHeight(val: number) {\n        this._rowHeight = Math.max(1, Math.round(coerceNumberProperty(val)));\n    }\n\n    private _rowHeight: number = 100;\n\n    /** Number of columns  */\n    @Input()\n    get cols(): number { return this._cols; }\n\n    set cols(val: number) {\n        this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));\n    }\n\n    private _cols: number = 6;\n\n    /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */\n    @Input()\n    get layout(): KtdGridLayout { return this._layout; }\n\n    set layout(layout: KtdGridLayout) {\n        /**\n         * Enhancement:\n         * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.\n         *\n         * Why:\n         * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and\n         * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when\n         * it is re-binded on the input.\n         */\n        this._layout = layout;\n    }\n\n    private _layout: KtdGridLayout;\n\n    get config(): KtdGridCfg {\n        return {\n            cols: this.cols,\n            rowHeight: this.rowHeight,\n            layout: this.layout,\n            preventCollision: this.preventCollision,\n        };\n    }\n\n    /** Total height of the grid */\n    private _height: number;\n    private _gridItemsRenderData: KtdDictionary<KtdGridItemRenderData<number>>;\n    private subscriptions: Subscription[];\n\n    constructor(private gridService: KtdGridService,\n                private elementRef: ElementRef,\n                private renderer: Renderer2,\n                private ngZone: NgZone) {\n\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        let needsCompactLayout = false;\n        let needsRecalculateRenderData = false;\n\n        // TODO: Does fist change need to be compacted by default?\n        // Compact layout whenever some dependent prop changes.\n        if (changes.compactType || changes.cols || changes.layout) {\n            needsCompactLayout = true;\n        }\n\n        // Check if wee need to recalculate rendering data.\n        if (needsCompactLayout || changes.rowHeight) {\n            needsRecalculateRenderData = true;\n        }\n\n        // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)\n        // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component\n        // and the ones that uses it.\n        if (needsCompactLayout && this.compactOnPropsChange) {\n            this.compactLayout();\n        }\n\n        if (needsRecalculateRenderData) {\n            this.calculateRenderData();\n        }\n    }\n\n    ngAfterContentInit() {\n        this.initSubscriptions();\n    }\n\n    ngAfterContentChecked() {\n        this.render();\n    }\n\n    resize() {\n        this.calculateRenderData();\n        this.render();\n    }\n\n    ngOnDestroy() {\n        this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    compactLayout() {\n        this.layout = compact(this.layout, this.compactType, this.cols);\n    }\n\n    getItemsRenderData(): KtdDictionary<KtdGridItemRenderData<number>> {\n        return {...this._gridItemsRenderData};\n    }\n\n    getItemRenderData(itemId: string): KtdGridItemRenderData<number> {\n        return this._gridItemsRenderData[itemId];\n    }\n\n    calculateRenderData() {\n        const clientRect = (this.elementRef.nativeElement as HTMLElement).getBoundingClientRect();\n        this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, clientRect.height);\n        this._height = getGridHeight(this.layout, this.rowHeight);\n    }\n\n    render() {\n        this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this._height}px`);\n        this.updateGridItemsStyles();\n    }\n\n    private updateGridItemsStyles() {\n        this._gridItems.forEach(item => {\n            const gridItemRenderData: KtdGridItemRenderData<number> | undefined = this._gridItemsRenderData[item.id];\n            if (gridItemRenderData == null) {\n                console.error(`Couldn\\'t find the specified grid item for the id: ${item.id}`);\n            } else {\n                item.setStyles(parseRenderItemToPixels(gridItemRenderData));\n            }\n        });\n    }\n\n    private initSubscriptions() {\n        this.subscriptions = [\n            this._gridItems.changes.pipe(\n                startWith(this._gridItems),\n                switchMap((gridItems: QueryList<KtdGridItemComponent>) => {\n                    return merge(\n                        ...gridItems.map((gridItem) => gridItem.dragStart$.pipe(map((event) => ({event, gridItem, type: 'drag'})))),\n                        ...gridItems.map((gridItem) => gridItem.resizeStart$.pipe(map((event) => ({event, gridItem, type: 'resize'})))),\n                    ).pipe(exhaustMap(({event, gridItem, type}) => {\n                        // Emit drag or resize start events. Ensure that is start event is inside the zone.\n                        this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout)));\n                        // Get the correct newStateFunc depending on if we are dragging or resizing\n                        const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing;\n\n                        // Perform drag sequence\n                        return this.performDragSequence$(gridItem, event, (gridItemId, config, compactionType, draggingData) =>\n                            calcNewStateFunc(gridItemId, config, compactionType, draggingData)\n                        ).pipe(map((layout) => ({layout, gridItem, type})));\n\n                    }));\n                })\n            ).subscribe(({layout, gridItem, type}) => {\n                this.layout = layout;\n                // Calculate new rendering data given the new layout.\n                this.calculateRenderData();\n                // Emit drag or resize end events.\n                (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout));\n                // Notify that the layout has been updated.\n                this.layoutUpdated.emit(layout);\n            })\n\n        ];\n    }\n\n    /**\n     * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding\n     * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.\n     * @param gridItem that is been dragged\n     * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag\n     * @param calcNewStateFunc function that return the new layout state and the drag element position\n     */\n    private performDragSequence$(gridItem: KtdGridItemComponent, pointerDownEvent: MouseEvent | TouchEvent,\n                                 calcNewStateFunc: (gridItemId: string, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData) => { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect }): Observable<KtdGridLayout> {\n\n        return new Observable<KtdGridLayout>((observer: Observer<KtdGridLayout>) => {\n            // Retrieve grid (parent) and gridItem (draggedElem) client rects.\n            const gridElemClientRect: ClientRect = getMutableClientRect(this.elementRef.nativeElement as HTMLElement);\n            const dragElemClientRect: ClientRect = getMutableClientRect(gridItem.elementRef.nativeElement as HTMLElement);\n\n            const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;\n\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\n\n            // Create placeholder element. This element would represent the position where the dragged/resized element would be if the action ends\n            const placeholderElement: HTMLDivElement = this.renderer.createElement('div');\n            placeholderElement.style.width = `${dragElemClientRect.width}px`;\n            placeholderElement.style.height = `${dragElemClientRect.height}px`;\n            placeholderElement.style.transform = `translateX(${dragElemClientRect.left - gridElemClientRect.left}px) translateY(${dragElemClientRect.top - gridElemClientRect.top}px)`;\n\n            this.renderer.addClass(placeholderElement, 'ktd-grid-item-placeholder');\n            this.renderer.appendChild(this.elementRef.nativeElement, placeholderElement);\n\n            let newLayout: KtdGridLayoutItem[];\n\n            // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.\n            //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.\n            //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.\n            const scrollSubscription = this.ngZone.runOutsideAngular(() =>\n                (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(\n                    map((event) => ({\n                        pointerX: ktdPointerClientX(event),\n                        pointerY: ktdPointerClientY(event)\n                    })),\n                    ktdScrollIfNearElementClientRect$(scrollableParent, {scrollStep: this.scrollSpeed})\n                )).pipe(\n                    takeUntil(ktdMouseOrTouchEnd(document))\n                ).subscribe());\n\n            /**\n             * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission\n             */\n            const subscription = this.ngZone.runOutsideAngular(() =>\n                merge(\n                    combineLatest([\n                        this.gridService.mouseOrTouchMove$(document),\n                        ...(!scrollableParent ? [of({top: 0, left: 0})] : [\n                            ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(\n                                startWith({top: 0, left: 0}) // Force first emission to allow CombineLatest to emit even no scroll event has occurred\n                            )\n                        ])\n                    ])\n                ).pipe(\n                    takeUntil(ktdMouseOrTouchEnd(document)),\n                ).subscribe(([pointerDragEvent, scrollDifference]: [MouseEvent | TouchEvent, { top: number, left: number }]) => {\n                        pointerDragEvent.preventDefault();\n\n                        /**\n                         * Set the new layout to be the layout in which the calcNewStateFunc would be executed.\n                         * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,\n                         * some utilities from 'react-grid-layout' would not work as expected.\n                         */\n                        const currentLayout: KtdGridLayout = newLayout || this.layout;\n\n                        const {layout, draggedItemPos} = calcNewStateFunc(gridItem.id, {\n                            layout: currentLayout,\n                            rowHeight: this.rowHeight,\n                            cols: this.cols,\n                            preventCollision: this.preventCollision\n                        }, this.compactType, {\n                            pointerDownEvent,\n                            pointerDragEvent,\n                            gridElemClientRect,\n                            dragElemClientRect,\n                            scrollDifference\n                        });\n                        newLayout = layout;\n\n                        this._height = getGridHeight(newLayout, this.rowHeight);\n\n                        this._gridItemsRenderData = layoutToRenderItems({\n                            cols: this.cols,\n                            rowHeight: this.rowHeight,\n                            layout: newLayout,\n                            preventCollision: this.preventCollision,\n                        }, gridElemClientRect.width, gridElemClientRect.height);\n\n                        const placeholderStyles = parseRenderItemToPixels(this._gridItemsRenderData[gridItem.id]);\n\n                        // Put the real final position to the placeholder element\n                        placeholderElement.style.width = placeholderStyles.width;\n                        placeholderElement.style.height = placeholderStyles.height;\n                        placeholderElement.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`;\n\n                        // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)\n                        this._gridItemsRenderData[gridItem.id] = {\n                            ...draggedItemPos,\n                            id: this._gridItemsRenderData[gridItem.id].id\n                        };\n\n                        this.render();\n                    },\n                    (error) => observer.error(error),\n                    () => {\n                        this.ngZone.run(() => {\n                            // Remove drag classes\n                            this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');\n                            this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\n\n                            // Remove placeholder element from the dom\n                            // NOTE: If we don't put the removeChild inside the zone it would not work... This may be a bug from angular or maybe is the intended behaviour, although strange.\n                            // It should work since AFAIK this action should not be done in a CD cycle.\n                            this.renderer.removeChild(this.elementRef.nativeElement, placeholderElement);\n\n                            if (newLayout) {\n                                // Prune react-grid-layout compact extra properties.\n                                observer.next(newLayout.map(item => ({\n                                    id: item.id,\n                                    x: item.x,\n                                    y: item.y,\n                                    w: item.w,\n                                    h: item.h\n                                })) as KtdGridLayout);\n                            } else {\n                                // TODO: Need we really to emit if there is no layout change but drag started and ended?\n                                observer.next(this.layout);\n                            }\n\n                            observer.complete();\n                        });\n\n                    }));\n\n\n            return () => {\n                scrollSubscription.unsubscribe();\n                subscription.unsubscribe();\n            };\n        });\n    }\n\n\n    // tslint:disable-next-line\n    static ngAcceptInputType_cols: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_rowHeight: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_scrollSpeed: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_compactOnPropsChange: BooleanInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_preventCollision: BooleanInput;\n}\n\n","<ng-content></ng-content>\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { KtdGridComponent } from './grid.component';\nimport { KtdGridItemComponent } from './grid-item/grid-item.component';\nimport { KtdGridDragHandle } from './directives/drag-handle';\nimport { KtdGridResizeHandle } from './directives/resize-handle';\nimport { KtdGridService } from './grid.service';\n\n@NgModule({\n    declarations: [\n        KtdGridComponent,\n        KtdGridItemComponent,\n        KtdGridDragHandle,\n        KtdGridResizeHandle\n    ],\n    exports: [\n        KtdGridComponent,\n        KtdGridItemComponent,\n        KtdGridDragHandle,\n        KtdGridResizeHandle\n    ],\n    providers: [\n        KtdGridService\n    ],\n    imports: [\n        CommonModule\n    ]\n})\nexport class KtdGridModule {}\n"]}